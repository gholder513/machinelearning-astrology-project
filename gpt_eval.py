"""
Load horoscopes & train embedding model (reuse prepare_embeddings_and_traits).
For 10 rounds:
- Ask user for their zodiac sign and a short description of themselves (once).
- Generate a short horoscope using AI, aided by top similar training examples.
- Show the horoscope and ask the user if it's accurate (y/n or 1-5).
- Report overall accuracy.
"""

from __future__ import annotations

import os
import random
from typing import List, Tuple

import numpy as np
from dotenv import load_dotenv
from openai import OpenAI

from config import N_TOP_EXAMPLES
from load import load_horoscopes
from traits import prepare_embeddings_and_traits
from classify import top_examples_for_sign


def _init_openai_client() -> OpenAI:
    """
    Initialize OpenAI client using OPENAI_API_KEY from environment.
    """
    load_dotenv()  # load from .env if present
    api_key = os.getenv("OPENAI_API_KEY")

    if not api_key:
        raise RuntimeError(
            "OPENAI_API_KEY is not set. "
            "Create a .env file with OPENAI_API_KEY=your_key_here "
            "or export it in your shell."
        )

    client = OpenAI(api_key=api_key)
    return client


def _pick_style(round_idx: int) -> Tuple[str, str]:
    """
    Return (tone_hint, focus_hint) based on the current round.
    This introduces structured variation between calls.
    """
    # You can tweak or expand these lists however you like.
    tone_options = [
        "warm and encouraging",
        "direct and practical",
        "playful and lighthearted",
        "introspective and reflective",
        "mysterious and poetic",
    ]
    focus_options = [
        "relationships and emotional patterns",
        "creative expression and hobbies",
        "daily habits and routines",
        "career, ambition, and long-term goals",
        "inner growth, mindset, and self-talk",
        "body, health, and physical environment",
    ]

    # Deterministic but varied based on round index
    tone = tone_options[round_idx % len(tone_options)]
    focus = focus_options[(round_idx * 2) % len(focus_options)]

    return tone, focus


def _generate_horoscope(
    client: OpenAI,
    sign: str,
    user_description: str,
    similar_examples: List[Tuple[str, float]],
    round_idx: int,
    model: str = "gpt-4.1-mini",
) -> str:
    """
    Use OpenAI to generate a short horoscope for the given sign and user description.
    similar_examples: list of (training_text, similarity_score)
    The round_idx is used to systematically vary tone and focus.
    """

    examples_text = ""
    if similar_examples:
        examples_list = []
        for ex_text, ex_sim in similar_examples:
            snippet = ex_text.replace("\n", " ").strip()
            if len(snippet) > 200:
                snippet = snippet[:200] + "..."
            examples_list.append(f"- (sim {ex_sim:.3f}) {snippet}")
        examples_text = "\n".join(examples_list)

    tone_hint, focus_hint = _pick_style(round_idx)

    system_prompt = (
        "You are an astrology assistant that writes concise, personality-focused horoscopes.\n"
        "You will be given a zodiac sign, a short description of the person, and some example "
        "horoscope snippets for that sign.\n"
        "Your job is to generate a short (3–4 sentence) horoscope that feels accurate and "
        "reflective of the person's character, not generic fluff.\n"
        "VARY your style from call to call: don't always start with 'Today' or 'This', "
        "change sentence structure, and avoid reusing distinctive phrases.\n"
        "Do not copy any training text verbatim.\n"
    )

    user_prompt = f"""
ZODIAC SIGN: {sign.upper()}
USER DESCRIPTION: "{user_description}"

Desired tone for THIS horoscope: {tone_hint}.
Primary focus for THIS horoscope: {focus_hint}.

Training horoscope snippets for this sign (and their similarity scores):
{examples_text if examples_text else "(no examples provided)"}

Write a short, natural horoscope (3–4 sentences) that:
  - Feels tailored to this person.
  - Leans into the typical traits of {sign.title()}.
  - Uses the requested tone and focus for THIS round.
  - Does NOT reuse the exact same opening lines you've used in other horoscopes
    (avoid starting every time with phrases like 'Today invites you to' or 'Today you...').
  - Does NOT repeat all of the user's hobbies every time; sometimes highlight just one
    or two and connect them to deeper themes (emotions, growth, choices, mindset).
  - Avoids repeating the training snippets verbatim.
  - Does NOT mention that it was generated by AI or that it's an example.
"""

    # Add some randomness via sampling parameters
    # You can tune these for more or less variance
    resp = client.chat.completions.create(
        model=model,
        messages=[
            {"role": "system", "content": system_prompt},
            {"role": "user", "content": user_prompt},
        ],
        temperature=0.95,        # slightly higher than before for more variety
        top_p=0.9,
        presence_penalty=0.7,    # encourages exploring new ideas
        frequency_penalty=0.4,   # discourages exact repeats
        max_tokens=300,
    )

    return resp.choices[0].message.content.strip()


def main():
    # Init OpenAI and embeddings
    print("Initializing OpenAI client...")
    client = _init_openai_client()

    print("Loading horoscope dataset and training embedding model...")
    df = load_horoscopes()
    descriptions = df["clean_description"].tolist()
    signs_array = df["sign"].values

    # reuse your existing embedding pipeline
    model, sign_centroids, sign_traits = prepare_embeddings_and_traits(df)

    # For example lookup, we need embeddings for each description
    print(f"Computing embeddings for {len(descriptions)} descriptions for similarity lookup...")
    embeddings = model.encode(
        descriptions,
        batch_size=32,
        convert_to_numpy=True,
        show_progress_bar=False,
    )

    print("\nAI-aided horoscope evaluator")
    print("--------------------------------")
    print("You will be asked for your sign & a short self-description.")
    print("We will generate 10 horoscopes and ask if each one feels accurate.\n")

    total_rounds = 10
    accurate_count = 0
    firstRoundFlag = True
    user_sign = ""
    user_desc = ""

    for round_idx in range(1, total_rounds + 1):
        print(f"\n=== Round {round_idx} of {total_rounds} ===")
        if firstRoundFlag:
            user_sign = input("Enter your zodiac sign (e.g., aries, taurus, ...) or 'q' to quit: ").strip().lower()

        if user_sign == "q":
            total_rounds = round_idx - 1
            break

        if firstRoundFlag:
            user_desc = input("Enter a short description of yourself: ").strip()

        # Validate input
        while not user_sign or not user_desc:
            print("Error: Both zodiac sign and description are required fields.")
            user_sign = input("Enter your zodiac sign (e.g., aries, taurus, ...) or 'q' to quit: ").strip().lower()

            if user_sign == "q":
                total_rounds = round_idx - 1
                break

            user_desc = input("Enter a short description of yourself: ").strip()

        if user_sign == "q":
            break

        firstRoundFlag = False

        # Find top similar training examples for this sign to feed into GPT
        # First compute embedding for the user's description
        user_emb = model.encode(user_desc, convert_to_numpy=True)

        similar_examples = top_examples_for_sign(
            sign=user_sign,
            query_emb=user_emb,
            descriptions=descriptions,
            embeddings=embeddings,
            signs=signs_array,
            k=N_TOP_EXAMPLES,
        )

        # Generate horoscope with GPT
        print("\nGenerating horoscope...")
        horoscope = _generate_horoscope(
            client=client,
            sign=user_sign,
            user_description=user_desc,
            similar_examples=similar_examples,
            round_idx=round_idx,
        )

        print("\n--- Generated Horoscope ---")
        print(horoscope)
        print("---------------------------\n")

        # Ask user if it's accurate
        while True:
            ans = input("Does this feel accurate to your character? (y/n or 1-5): ").strip().lower()
            if ans in {"y", "yes"}:
                accurate_count += 1
                break
            elif ans in {"n", "no"}:
                break
            elif ans in {"1", "2", "3", "4", "5"}:
                # treat 4 or 5 as "accurate"
                if ans in {"4", "5"}:
                    accurate_count += 1
                elif ans in {"2", "3"}:
                    accurate_count += 0.5
                break
            else:
                print("Please answer with y/n or 1-5.")

    accuracy = accurate_count / total_rounds if total_rounds > 0 else 0.0
    print(f"\nOverall 'accuracy' (fraction of rounds you said yes / high rating): {accuracy:.2f}")


if __name__ == "__main__":
    main()
